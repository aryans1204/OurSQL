int rng; // must be a global var inside BTree to indicate range of num of keys
BTree* CH; // arr of children pointers
int tot; // curr num of keys
bool isleaf; // is the curr node a leaf?

void BTree::BTree:deleteLeaf (int index)
{
	for (int i = index+1; i < tot; ++i)
		keys[i-1] = keys[i];
	tot--;
}

int BTree::BTree::getBefore(int index)
{
	BTree *current = CH[index];
	
    while (! current -> leaf) {current = current ->CH [current -> tot];}
    return current -> keys[current -> tot-1];
}

void BTree::BTree::deleteNonLeaf(int index)
{

	int k = keys[index];

	if (CH[idx]->tot >= rng)
	{
		int before = getBefore(index);
		keys[index] = before;
		
        
        CH[index] -> delete(before);
	}

	else if (CH[index+1] -> tot >= rng)
	{
		int next = getNext(index);
		keys[index] = next;


		CH[index+1] -> delete(next);
	}

	else
	{
		merge(index); CH[index] -> delete(k);
	}
}

int BTreeNode::getNext(int index)
{
	BTree *current = CH[index+1];
	while (! current -> leaf) {current = current -> C[0];}
	return current -> keys[0];
}

void BTree::BTree::merge(int index)
{
	BTree *child = CH[index];
	child -> keys[t-1] = keys[index];

    BTree *neighbor = C[index + 1];

	for (int i = 0; i < neighbor->tot; ++i)
		
        child->keys[i+t] = neighbor->keys[i];

	if (! child->leaf)
	{
		for(int i = 0; i <= neighbor->tot; ++i)
			child->CH[i + t] = neighbor->CJ[i];
	}

	for (int i = index+1; i < tot; ++i)
		keys[i-1] = keys[i];

	for (int i = index + 2; i <= tot; ++i)
		CH[i-1] = CH[i];

	child->n += neighbor->n+1;
	n--; delete(neighbor);
}

bool BTree::delete(int k)
{
    int index = findK(k)

    if (keys[idx] == k && index < tot) {
		if (isleaf) deleteLeaf(index);
		else deleteNonLeaf(index); }
	
    else
	{
		if (isleaf) return 0;

        if(index == tot) isFlag = 1
        else isFlag = 0

		if (CH[index]->tot < t) put(index);

		if (index > n && isFlag) CH[index-1] -> delete(k);
		else CH[index] -> delete(k);
	} return 1;
}
